부동 소수점을 메모리에 저장하는 방법  (참고 ex03 > exam0340)


부동 소수점을 2진수화 시켜야 메모리에 저장할 수 있다

ex) 12.375

1) 소수점 앞의 값
      12   >   1100
         (2진수)

2) 소수점 뒤의 값

0.375 x 2 = 0.75 > 0
0.75 x 2 = 1.5 > 1
0.5 x 2 = 1.0 > 1
0.375 > 0.011
          (2진수)

3) 소수점 앞+ 소수점 뒤 = 1100.011


4)정규화를 수행하여 소수점을 없앤다
- 소수점 왼쪽에 한개의 1만 남게 하라
>>  1100.011 x 2^3 = 1.100011

-소수점 왼쪽의 숫자 1을 버린다
0.100011 x 2^3

              이 부분에 저장하는 것을
                  지수부라고 한다
                     __________
32bit 메모리   [0l l l l l l l l | l l l l l l l l l l l l l . . .   l0]
                      (8비트)





12.375 > 64bit (2진수 화시키면) 




*부동 소수점 리터럴

1)4byte 부동소수점                       12.375f     12.375F(이걸 많이 씀)    

1)8byte 부동소수점                      12.375(이걸 많이 씀)       12.375d     12.375D


*정수는 주로 4byte를 사용한다 ( 뒤에 생략 가능)

1)  123 > 4 byte 정수

2)   123l }   8byte 정수
     123L }




메모리 크기에 따른 부동 소수점 값의 범위
                                
                     이과정을 통해 메모리에 값이 저장되기 때문에 명확하게 -? ~ +? 범위를 산정할 수 없다
                           소수점 앞 자리수, 소수점 뒤 자리수도 결정할 수 없다 (소수점이 이동하기 때문)  ==> 다만 IEE-754 방식에 따라 2진수로 바꾸더라도 
										       값이 짤리지 않는 범위를 대략적으로 알 수 있다
                            |______________________________________________________________________|                         *4byte는 소수점을 제거했을 때 7개의 숫자라면
4byte 메모리인 경우  (소수점 앞의 정수값, 소수점 이하의 값)  >> 2진수화 >>정규화 처리                           거의 99.9% 메모리에 저장할 수 있다
(단정도)-single preci                           							*8byte의 경우는 소수점 제거 후 16개의 숫자라면
											거의 99.9% 메모리에 저장할 수 있다
8byte 메모리인 경우							    	      -4byte 7자리, 8byte 16자리 를 유효자릿수라고 부름
(배정도) 										8byte 메모리는 4byte 메모리보다 2배 더 많은 수를 저장할 수 있다
									  	
										
*부동 소수점의 유효범위

4byte > 7자리 유효  (2 이상의 숫자는 짤린다)
                           정수 리터럴과 달리 오류가 발생하지 않는다

8byte > 16자리 유효 (2 이상의 숫자는 짤린다)




부동 소수점 활용 분야

1)암호  >  비트코인  (GPU가 담당)

2)그래픽
3D 세계에서 좌표의 변환은 반드시 부동 소수점을 생성시킨다

> 3D 그래픽 처리는 부동 소수점 연산을 많이 수행  >  cpu에 부담을 줌   >   GPU(그래픽 프로세스 유닛)가 담당

